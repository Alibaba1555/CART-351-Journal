<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tianshun's Coding Journal</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>

<canvas id="particles"></canvas>

<header>
  <h1 class="typing">Tianshun's 351 Journal</h1>
</header>

<section class="entry">
  <div class="title">Github repository</div>
  <div class="content">
    <a href="https://github.com/Alibaba1555/CART-351-A" target="_blank">
      <button>Open on GitHub</button>
    </a>
  </div>
</section>


<!-- Week 1 -->
<section class="entry">
  <div class="date">üóì October 8, 2025</div>
  <div class="title">Reflections on Project 1: AIR QUEST</div>
  <div class="content">
This week, I finished building my first Python terminal app: AIR QUEST.  
The idea started from curiosity ‚Äî I wanted to make air quality data feel more alive, not just numbers.

By using the [requests] library, I could connect directly to the World Air Quality API.  
[Rich] and [PyFiglet] added a playful and artistic layer ‚Äî colors, ASCII banners, progress bars ‚Äî all inside the terminal.  
It felt like designing a mini interactive world in text form.

The most exciting part was turning something environmental and scientific into something expressive.  
Watching the AQI bar grow, seeing emojis change with the air quality ‚Äî it gave personality to data.  
Even though it runs entirely in the console, it feels emotional, like a digital creature breathing city air.

Below is a small web version of my AIR QUEST ‚Äî you can enter any city to see real-time air quality:
  </div>

  <!-- API -->
  <div class="aqi-box">
    <input type="text" id="city" placeholder="Enter city (e.g. Montreal)">
    <button onclick="fetchAQI()">Check Air</button>
    <div id="aqiResult">üåç Waiting for input...</div>
  </div>
</section>

<!-- Week 2 -->
<section class="entry">
  <canvas class="donut-bg" id="donutBg"></canvas>
  <div class="date">WEEK 2 October 20, 2025</div>
  <div class="title">Flask Exercise II ‚Äî Turning Code into a Web Experience</div>
  <div class="content">
This week I completed **Exercise II: Working with Flask**, my first web app that runs entirely inside the browser.  
Compared with my previous terminal-based projects, this one felt more visual and interconnected ‚Äî where logic, layout, and design come together.

I started by learning the basic structure of Flask:  
each **route** (like <code>/</code>, <code>/t1</code>, <code>/t2</code>, and <code>/thank_you_t2</code>) is linked to a view function,  
which renders an HTML template using <code>render_template()</code>.  
Inside the templates, I used **Jinja** for loops, if-statements, and <code>url_for()</code> to load dynamic content.  
For the **/t2** page, I created a **GET form** that collects user input, combines the text in Python, replaces all vowels with <code>*</code>, and returns the processed result to the page.

After finishing the main logic, I focused on the aesthetics.  
I redesigned the site to look like a small ‚Äúdonut shop‚Äù web page rather than a coding exercise,  
  </div>
</section>

<!-- Week 3 -->
<section class="entry">
  <div class="date">Week 3 ‚Äî October 27, 2025</div>
  <div class="title">Reflection: FLASK III and FETCH</div>
  <div class="content">
    This week deepened my understanding of how client and server communicate through HTTP.  
    I learned that redirecting after a GET request isn‚Äôt just a formality‚Äîit prevents messy URLs and keeps data secure.  
    Working with Flask sessions showed me how to store temporary user data between requests,  
    while still understanding that it‚Äôs not meant for sensitive information.  
    The highlight of the week was using the <code>Fetch API</code> to send and receive data asynchronously,  
    letting the page update dynamically without reloading.  
    It felt like watching static code come alive.  
    Overall, Week 3 made me appreciate how structure, flow, and interactivity all come together in modern web apps.
  </div>
</section>

<!-- Week 4 -->
<section class="entry">
  <div class="date">Week 4 ‚Äî November 3, 2025</div>
  <div class="title">Reflection: Flask + Fetch Interaction</div>
  <div class="content">
    This week I worked on connecting Flask with client-side JavaScript using <code>fetch()</code>,
    and honestly, it was challenging.  
    Instead of relying on simple forms, I had to send JSON data manually, handle POST requests, and update the UI dynamically with the server‚Äôs response.  
    Debugging the data flow between the browser and Flask took time, especially when managing
    asynchronous logic and saving data into a text file.  
    Even though it felt difficult at moments, seeing my interactive drawing data send, save, and reappear on the page made it really satisfying.  
    I feel like I‚Äôm starting to understand how real interactive web tools are built.
  </div>
</section>

<!-- Week 5 -->
<section class="entry">
  <div class="date">Week 5 ‚Äî November 10, 2025</div>
  <div class="title">Reflection: Project II ‚Äî Collective Drums</div>
  <div class="content">
    My partner and I developed <strong>Collective Drums</strong>, an interactive platform where each user creates a 6√ó16 rhythm pattern and contributes it to a shared musical composition.  
    The project merges sound design, data visualization, and community participation into one evolving experience.  

    Technically, this week was a breakthrough.  
    I learned how to connect front-end JavaScript and Tone.js with Flask routes using the <code>fetch()</code> API,  
    handle JSON data storage on the server, and update the page dynamically as new users contribute.  
    Adding new features like <strong>sound kit selection</strong>, a <strong>message system</strong>, and a <strong>recording function</strong> made the application feel like a living instrument rather than just a web tool.  

    This week‚Äôs process challenged everything I had learned so far in Python, Flask, and web interaction design.  
    The result isn‚Äôt only a working app, but also a reflection on how creative coding can transform participation into shared experience.
  </div>
  <section class="entry" id="mini-drum">
  <div class="title">Mini Drum Preview</div>
  <div class="content">
    <div class="mini-controls">
      <label>BPM <input id="miniBpm" type="range" min="60" max="180" value="110"> <span id="miniBpmVal">110</span></label>
      <button id="miniPlay">Play</button>
      <button id="miniStop">Stop</button>
      <button id="miniRandom">Random</button>
      <button id="miniClear">Clear</button>
    </div>
    <div class="mini-legend">
      <span>Kick</span><span>Snare</span><span>Hat</span><span>Clap</span>
    </div>
    <div id="miniGrid" class="mini-grid"></div>
  </div>
</section>
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
</section>

<!-- Week 6 -->
<section class="entry">
  <div class="date">Week 6 ‚Äî November 17, 2025</div>
  <div class="title">EX 4</div>
  </section>

  <!-- Week 7 -->
<section class="entry week7">
  <canvas id="patternCanvas"></canvas>

  <div class="date">Week 7 ‚Äî November 24, 2025</div>
  <div class="title">Reflection: Exercise V ‚Äî Patterns & MongoDB</div>

  <div class="content">
    This week was all about connecting data to visual meaning.  
    I worked on Exercise V, where we used MongoDB Atlas as a real database and wrote queries that control different visual patterns.  
    Compared to earlier Flask exercises, this felt like a full system: server logic, database structure, and front-end visualization all depended on each other.

    The first challenge was setting up my own MongoDB collection correctly and making sure the insert script only ran once.  
    Seeing 1000 randomized entries appear in Atlas was satisfying, it made the project feel real, like I was working with an actual survey dataset instead of dummy lists.

    Writing the queries was surprisingly fun.  
    I started to understand how MongoDB filtering and sorting can shape the story the dataset tells.  
    Queries like ‚Äúafter-mood positive only,‚Äù ‚Äúevents grouped by name,‚Äù or ‚Äúnegative moods under different weather‚Äù reminded me that the database isn‚Äôt just storage, it‚Äôs already a kind of logic engine.

    The most time-consuming part was visualization.  
    Every query needed a unique pattern, so I had to design visual systems instead of just drawing points randomly.  
    I ended up making animated clusters for positive moods, timeline-style stripes for events, stacked cloud bars for affect strength on Monday/Tuesday, and bamboo-tube columns for negative moods grouped by weather.  
    Adding movement made the patterns easier to read and also more alive, like the data was breathing instead of sitting still.

    Overall, this exercise tied together everything we‚Äôve been learning:  
    Flask routes, fetch communication, JSON results, and now real database logic.  
    It felt like stepping from ‚Äúcoding exercises‚Äù into something closer to real creative data tools.
  </div>
   <button id="generatePattern">Generate Mini Pattern</button>
 
  </div>
</section>

</section>

<footer>
  ¬© 2025 Tianshun Wu ‚Äî Computation Arts  CART 351 Journal
</footer>

<script src="app.js"></script>
</body>
</html>
